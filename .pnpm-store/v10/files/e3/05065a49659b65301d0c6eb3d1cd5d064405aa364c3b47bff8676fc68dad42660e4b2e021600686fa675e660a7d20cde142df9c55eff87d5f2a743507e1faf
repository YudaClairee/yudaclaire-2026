{"version":3,"file":"sourceLocation.js","sources":["../../../src/import-protection-plugin/sourceLocation.ts"],"sourcesContent":["import { SourceMapConsumer } from 'source-map'\nimport * as path from 'pathe'\n\nimport { escapeRegExp, getOrCreate, normalizeFilePath } from './utils'\nimport type { Loc } from './trace'\nimport type { RawSourceMap } from 'source-map'\n\n// Source-map type compatible with both Rollup's SourceMap and source-map's\n// RawSourceMap.  Structural type avoids version: number vs string mismatch.\n\n/**\n * Minimal source-map shape used throughout the import-protection plugin.\n */\nexport interface SourceMapLike {\n  file?: string\n  sourceRoot?: string\n  version: number | string\n  sources: Array<string>\n  names: Array<string>\n  sourcesContent?: Array<string | null>\n  mappings: string\n}\n\n// Transform result provider (replaces ctx.load() which doesn't work in dev)\nexport interface TransformResult {\n  code: string\n  map: SourceMapLike | undefined\n  originalCode: string | undefined\n  /** Precomputed line index for `code` (index → line/col). */\n  lineIndex?: LineIndex\n}\n\n/**\n * Provides the transformed code and composed sourcemap for a module.\n *\n * Populated from a late-running transform hook. By the time `resolveId`\n * fires for an import, the importer has already been fully transformed.\n */\nexport interface TransformResultProvider {\n  getTransformResult: (id: string) => TransformResult | undefined\n}\n\n// Index → line/column conversion\n\nexport type LineIndex = {\n  offsets: Array<number>\n}\n\nexport function buildLineIndex(code: string): LineIndex {\n  const offsets: Array<number> = [0]\n  for (let i = 0; i < code.length; i++) {\n    if (code.charCodeAt(i) === 10) {\n      offsets.push(i + 1)\n    }\n  }\n  return { offsets }\n}\n\nfunction upperBound(values: Array<number>, x: number): number {\n  let lo = 0\n  let hi = values.length\n  while (lo < hi) {\n    const mid = (lo + hi) >> 1\n    if (values[mid]! <= x) lo = mid + 1\n    else hi = mid\n  }\n  return lo\n}\n\nfunction indexToLineColWithIndex(\n  lineIndex: LineIndex,\n  idx: number,\n): { line: number; column0: number } {\n  const offsets = lineIndex.offsets\n  const ub = upperBound(offsets, idx)\n  const lineIdx = Math.max(0, ub - 1)\n  const line = lineIdx + 1\n\n  const lineStart = offsets[lineIdx] ?? 0\n  return { line, column0: Math.max(0, idx - lineStart) }\n}\n\n/**\n * Pick the most-likely original source text for `importerFile` from\n * a sourcemap that may contain multiple sources.\n */\nexport function pickOriginalCodeFromSourcesContent(\n  map: SourceMapLike | undefined,\n  importerFile: string,\n  root: string,\n): string | undefined {\n  if (!map?.sourcesContent || map.sources.length === 0) {\n    return undefined\n  }\n\n  const file = normalizeFilePath(importerFile)\n  const sourceRoot = map.sourceRoot\n  const fileSeg = file.split('/').filter(Boolean)\n\n  const resolveBase = sourceRoot ? path.resolve(root, sourceRoot) : root\n\n  let bestIdx = -1\n  let bestScore = -1\n\n  for (let i = 0; i < map.sources.length; i++) {\n    const content = map.sourcesContent[i]\n    if (typeof content !== 'string') continue\n\n    const src = map.sources[i] ?? ''\n\n    const normalizedSrc = normalizeFilePath(src)\n    if (normalizedSrc === file) {\n      return content\n    }\n\n    let resolved: string\n    if (!src) {\n      resolved = ''\n    } else if (path.isAbsolute(src)) {\n      resolved = normalizeFilePath(src)\n    } else {\n      resolved = normalizeFilePath(path.resolve(resolveBase, src))\n    }\n    if (resolved === file) {\n      return content\n    }\n\n    // Count matching path segments from the end.\n    const normalizedSrcSeg = normalizedSrc.split('/').filter(Boolean)\n    const resolvedSeg =\n      resolved !== normalizedSrc\n        ? resolved.split('/').filter(Boolean)\n        : normalizedSrcSeg\n    const score = Math.max(\n      segmentSuffixScore(normalizedSrcSeg, fileSeg),\n      segmentSuffixScore(resolvedSeg, fileSeg),\n    )\n\n    if (score > bestScore) {\n      bestScore = score\n      bestIdx = i\n    }\n  }\n\n  if (bestIdx !== -1 && bestScore >= 1) {\n    return map.sourcesContent[bestIdx] ?? undefined\n  }\n\n  return map.sourcesContent[0] ?? undefined\n}\n\n/** Count matching path segments from the end of `aSeg` against `bSeg`. */\nfunction segmentSuffixScore(aSeg: Array<string>, bSeg: Array<string>): number {\n  let score = 0\n  for (\n    let i = aSeg.length - 1, j = bSeg.length - 1;\n    i >= 0 && j >= 0;\n    i--, j--\n  ) {\n    if (aSeg[i] !== bSeg[j]) break\n    score++\n  }\n  return score\n}\n\nasync function mapGeneratedToOriginal(\n  map: SourceMapLike | undefined,\n  generated: { line: number; column0: number },\n  fallbackFile: string,\n): Promise<Loc> {\n  const fallback: Loc = {\n    file: fallbackFile,\n    line: generated.line,\n    column: generated.column0 + 1,\n  }\n\n  if (!map) {\n    return fallback\n  }\n\n  const consumer = await getSourceMapConsumer(map)\n  if (!consumer) return fallback\n\n  try {\n    const orig = consumer.originalPositionFor({\n      line: generated.line,\n      column: generated.column0,\n    })\n    if (orig.line != null && orig.column != null) {\n      return {\n        file: orig.source ? normalizeFilePath(orig.source) : fallbackFile,\n        line: orig.line,\n        column: orig.column + 1,\n      }\n    }\n  } catch {\n    // Malformed sourcemap\n  }\n\n  return fallback\n}\n\nconst consumerCache = new WeakMap<object, Promise<SourceMapConsumer | null>>()\n\nfunction toRawSourceMap(map: SourceMapLike): RawSourceMap {\n  return {\n    ...map,\n    file: map.file ?? '',\n    version: Number(map.version),\n    sourcesContent: map.sourcesContent?.map((s) => s ?? '') ?? [],\n  }\n}\n\nasync function getSourceMapConsumer(\n  map: SourceMapLike,\n): Promise<SourceMapConsumer | null> {\n  const cached = consumerCache.get(map)\n  if (cached) return cached\n\n  const promise = (async () => {\n    try {\n      return await new SourceMapConsumer(toRawSourceMap(map))\n    } catch {\n      return null\n    }\n  })()\n\n  consumerCache.set(map, promise)\n  return promise\n}\n\nexport type ImportLocEntry = { file?: string; line: number; column: number }\n\n/**\n * Cache for import statement locations with reverse index for O(1)\n * invalidation by file.  Keys: `${importerFile}::${source}`.\n */\nexport class ImportLocCache {\n  private cache = new Map<string, ImportLocEntry | null>()\n  private reverseIndex = new Map<string, Set<string>>()\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  get(key: string): ImportLocEntry | null | undefined {\n    return this.cache.get(key)\n  }\n\n  set(key: string, value: ImportLocEntry | null): void {\n    this.cache.set(key, value)\n    const file = key.slice(0, key.indexOf('::'))\n    getOrCreate(this.reverseIndex, file, () => new Set()).add(key)\n  }\n\n  clear(): void {\n    this.cache.clear()\n    this.reverseIndex.clear()\n  }\n\n  /** Remove all cache entries where the importer matches `file`. */\n  deleteByFile(file: string): void {\n    const keys = this.reverseIndex.get(file)\n    if (keys) {\n      for (const key of keys) {\n        this.cache.delete(key)\n      }\n      this.reverseIndex.delete(file)\n    }\n  }\n}\n\n// Import specifier search (regex-based)\n\nconst importPatternCache = new Map<string, Array<RegExp>>()\n\nexport function clearImportPatternCache(): void {\n  importPatternCache.clear()\n}\n\nfunction findFirstImportSpecifierIndex(code: string, source: string): number {\n  let patterns = importPatternCache.get(source)\n  if (!patterns) {\n    const escaped = escapeRegExp(source)\n    patterns = [\n      new RegExp(`\\\\bimport\\\\s+(['\"])${escaped}\\\\1`),\n      new RegExp(`\\\\bfrom\\\\s+(['\"])${escaped}\\\\1`),\n      new RegExp(`\\\\bimport\\\\s*\\\\(\\\\s*(['\"])${escaped}\\\\1\\\\s*\\\\)`),\n    ]\n    importPatternCache.set(source, patterns)\n  }\n\n  let best = -1\n  for (const re of patterns) {\n    const m = re.exec(code)\n    if (!m) continue\n    const idx = m.index + m[0].indexOf(source)\n    if (idx === -1) continue\n    if (best === -1 || idx < best) best = idx\n  }\n  return best\n}\n\n/**\n * Find the location of an import statement in a transformed module\n * by searching the post-transform code and mapping back via sourcemap.\n * Results are cached in `importLocCache`.\n */\nexport async function findImportStatementLocationFromTransformed(\n  provider: TransformResultProvider,\n  importerId: string,\n  source: string,\n  importLocCache: ImportLocCache,\n): Promise<Loc | undefined> {\n  const importerFile = normalizeFilePath(importerId)\n  const cacheKey = `${importerFile}::${source}`\n  if (importLocCache.has(cacheKey)) {\n    return importLocCache.get(cacheKey) ?? undefined\n  }\n\n  try {\n    const res = provider.getTransformResult(importerId)\n    if (!res) {\n      importLocCache.set(cacheKey, null)\n      return undefined\n    }\n\n    const { code, map } = res\n\n    const lineIndex = res.lineIndex ?? buildLineIndex(code)\n\n    const idx = findFirstImportSpecifierIndex(code, source)\n    if (idx === -1) {\n      importLocCache.set(cacheKey, null)\n      return undefined\n    }\n\n    const generated = indexToLineColWithIndex(lineIndex, idx)\n    const loc = await mapGeneratedToOriginal(map, generated, importerFile)\n    importLocCache.set(cacheKey, loc)\n    return loc\n  } catch {\n    importLocCache.set(cacheKey, null)\n    return undefined\n  }\n}\n\n/**\n * Find the first post-compile usage location for a denied import specifier.\n * Best-effort: searches transformed code for non-import uses of imported\n * bindings and maps back to original source via sourcemap.\n */\nexport async function findPostCompileUsageLocation(\n  provider: TransformResultProvider,\n  importerId: string,\n  source: string,\n  findPostCompileUsagePos: (\n    code: string,\n    source: string,\n  ) => { line: number; column0: number } | undefined,\n): Promise<Loc | undefined> {\n  try {\n    const importerFile = normalizeFilePath(importerId)\n    const res = provider.getTransformResult(importerId)\n    if (!res) return undefined\n    const { code, map } = res\n\n    if (!res.lineIndex) {\n      res.lineIndex = buildLineIndex(code)\n    }\n\n    const pos = findPostCompileUsagePos(code, source)\n    if (!pos) return undefined\n\n    return await mapGeneratedToOriginal(map, pos, importerFile)\n  } catch {\n    return undefined\n  }\n}\n\n/**\n * Annotate each trace hop with the location of the import that created the\n * edge (file:line:col). Skips steps that already have a location.\n */\nexport async function addTraceImportLocations(\n  provider: TransformResultProvider,\n  trace: Array<{\n    file: string\n    specifier?: string\n    line?: number\n    column?: number\n  }>,\n  importLocCache: ImportLocCache,\n): Promise<void> {\n  for (const step of trace) {\n    if (!step.specifier) continue\n    if (step.line != null && step.column != null) continue\n    const loc = await findImportStatementLocationFromTransformed(\n      provider,\n      step.file,\n      step.specifier,\n      importLocCache,\n    )\n    if (!loc) continue\n    step.line = loc.line\n    step.column = loc.column\n  }\n}\n\n// Code snippet extraction (vitest-style context around a location)\n\nexport interface CodeSnippet {\n  /** Source lines with line numbers, e.g. `[\"  6 | import { getSecret } from './secret.server'\", ...]` */\n  lines: Array<string>\n  /** The highlighted line (1-indexed original line number) */\n  highlightLine: number\n  /** Clickable file:line reference */\n  location: string\n}\n\n/**\n * Build a vitest-style code snippet showing lines surrounding a location.\n *\n * Prefers `originalCode` from the sourcemap's sourcesContent; falls back\n * to transformed code when unavailable.\n */\nexport function buildCodeSnippet(\n  provider: TransformResultProvider,\n  moduleId: string,\n  loc: Loc,\n  contextLines: number = 2,\n): CodeSnippet | undefined {\n  try {\n    const importerFile = normalizeFilePath(moduleId)\n    const res = provider.getTransformResult(moduleId)\n    if (!res) return undefined\n\n    const { code: transformedCode, originalCode } = res\n\n    const sourceCode = originalCode ?? transformedCode\n    const targetLine = loc.line // 1-indexed\n    const targetCol = loc.column // 1-indexed\n\n    if (targetLine < 1) return undefined\n\n    const wantStart = Math.max(1, targetLine - contextLines)\n    const wantEnd = targetLine + contextLines\n\n    // Advance to wantStart\n    let lineNum = 1\n    let pos = 0\n    while (lineNum < wantStart && pos < sourceCode.length) {\n      const ch = sourceCode.charCodeAt(pos)\n      if (ch === 10) {\n        lineNum++\n      } else if (ch === 13) {\n        lineNum++\n        if (\n          pos + 1 < sourceCode.length &&\n          sourceCode.charCodeAt(pos + 1) === 10\n        )\n          pos++\n      }\n      pos++\n    }\n    if (lineNum < wantStart) return undefined\n\n    const lines: Array<string> = []\n    let curLine = wantStart\n    while (curLine <= wantEnd && pos <= sourceCode.length) {\n      // Find end of current line\n      let eol = pos\n      while (eol < sourceCode.length) {\n        const ch = sourceCode.charCodeAt(eol)\n        if (ch === 10 || ch === 13) break\n        eol++\n      }\n      lines.push(sourceCode.slice(pos, eol))\n      curLine++\n      if (eol < sourceCode.length) {\n        if (\n          sourceCode.charCodeAt(eol) === 13 &&\n          eol + 1 < sourceCode.length &&\n          sourceCode.charCodeAt(eol + 1) === 10\n        ) {\n          pos = eol + 2\n        } else {\n          pos = eol + 1\n        }\n      } else {\n        pos = eol + 1\n      }\n    }\n\n    if (targetLine > wantStart + lines.length - 1) return undefined\n\n    const actualEnd = wantStart + lines.length - 1\n    const gutterWidth = String(actualEnd).length\n\n    const sourceFile = loc.file ?? importerFile\n    const snippetLines: Array<string> = []\n    for (let i = 0; i < lines.length; i++) {\n      const ln = wantStart + i\n      const lineContent = lines[i]!\n      const lineNumStr = String(ln).padStart(gutterWidth, ' ')\n      const marker = ln === targetLine ? '>' : ' '\n      snippetLines.push(`  ${marker} ${lineNumStr} | ${lineContent}`)\n\n      if (ln === targetLine && targetCol > 0) {\n        const padding = ' '.repeat(targetCol - 1)\n        snippetLines.push(`    ${' '.repeat(gutterWidth)} | ${padding}^`)\n      }\n    }\n\n    return {\n      lines: snippetLines,\n      highlightLine: targetLine,\n      location: `${sourceFile}:${targetLine}:${targetCol}`,\n    }\n  } catch {\n    return undefined\n  }\n}\n"],"names":[],"mappings":"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"}