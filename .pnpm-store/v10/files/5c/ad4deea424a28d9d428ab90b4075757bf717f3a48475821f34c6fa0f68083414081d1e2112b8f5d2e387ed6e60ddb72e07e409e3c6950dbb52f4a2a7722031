{"version":3,"file":"rewriteDeniedImports.js","sources":["../../../src/import-protection-plugin/rewriteDeniedImports.ts"],"sourcesContent":["import * as t from '@babel/types'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\n\nimport { MOCK_MODULE_ID } from './virtualModules'\nimport { getOrCreate } from './utils'\n\nexport function isValidExportName(name: string): boolean {\n  if (name === 'default' || name.length === 0) return false\n  const first = name.charCodeAt(0)\n  // First char: A-Z (65-90), a-z (97-122), _ (95), $ (36)\n  if (\n    !(\n      (first >= 65 && first <= 90) ||\n      (first >= 97 && first <= 122) ||\n      first === 95 ||\n      first === 36\n    )\n  )\n    return false\n  for (let i = 1; i < name.length; i++) {\n    const ch = name.charCodeAt(i)\n    // Subsequent: A-Z, a-z, 0-9 (48-57), _, $\n    if (\n      !(\n        (ch >= 65 && ch <= 90) ||\n        (ch >= 97 && ch <= 122) ||\n        (ch >= 48 && ch <= 57) ||\n        ch === 95 ||\n        ch === 36\n      )\n    )\n      return false\n  }\n  return true\n}\n\n/**\n * Best-effort static analysis of an importer's source to determine which\n * named exports are needed per specifier, to keep native ESM valid in dev.\n */\nexport function collectMockExportNamesBySource(\n  code: string,\n): Map<string, Array<string>> {\n  const ast = parseAst({ code })\n\n  const namesBySource = new Map<string, Set<string>>()\n  const add = (source: string, name: string) => {\n    if (name === 'default' || name.length === 0) return\n    getOrCreate(namesBySource, source, () => new Set<string>()).add(name)\n  }\n\n  for (const node of ast.program.body) {\n    if (t.isImportDeclaration(node)) {\n      if (node.importKind === 'type') continue\n      const source = node.source.value\n      for (const s of node.specifiers) {\n        if (!t.isImportSpecifier(s)) continue\n        if (s.importKind === 'type') continue\n        const importedName = t.isIdentifier(s.imported)\n          ? s.imported.name\n          : s.imported.value\n        // `import { default as x } from 'm'` only requires a default export.\n        if (importedName === 'default') continue\n        add(source, importedName)\n      }\n    }\n\n    if (t.isExportNamedDeclaration(node) && node.source?.value) {\n      if (node.exportKind === 'type') continue\n      const source = node.source.value\n      for (const s of node.specifiers) {\n        if (!t.isExportSpecifier(s)) continue\n        if (s.exportKind === 'type') continue\n        add(source, s.local.name)\n      }\n    }\n  }\n\n  const out = new Map<string, Array<string>>()\n  for (const [source, set] of namesBySource) {\n    out.set(source, Array.from(set).sort())\n  }\n  return out\n}\n\n/**\n * Rewrite static imports/re-exports from denied sources using Babel AST transforms.\n *\n * Transforms:\n *   import { a as b, c } from 'denied'\n * Into:\n *   import __tss_deny_0 from 'tanstack-start-import-protection:mock'\n *   const b = __tss_deny_0.a\n *   const c = __tss_deny_0.c\n *\n * Also handles:\n *   import def from 'denied'        -> import def from mock\n *   import * as ns from 'denied'    -> import ns from mock\n *   export { x } from 'denied'      -> export const x = mock.x\n *   export * from 'denied'          -> removed\n *   export { x as y } from 'denied' -> export const y = mock.x\n */\nexport function rewriteDeniedImports(\n  code: string,\n  id: string,\n  deniedSources: Set<string>,\n  getMockModuleId: (source: string) => string = () => MOCK_MODULE_ID,\n): { code: string; map?: object | null } | undefined {\n  const ast = parseAst({ code })\n  let modified = false\n  let mockCounter = 0\n\n  // Walk program body in reverse so splice indices stay valid\n  for (let i = ast.program.body.length - 1; i >= 0; i--) {\n    const node = ast.program.body[i]!\n\n    if (t.isImportDeclaration(node)) {\n      if (node.importKind === 'type') continue\n      if (!deniedSources.has(node.source.value)) continue\n\n      const mockVar = `__tss_deny_${mockCounter++}`\n      const replacements: Array<t.Statement> = []\n\n      replacements.push(\n        t.importDeclaration(\n          [t.importDefaultSpecifier(t.identifier(mockVar))],\n          t.stringLiteral(getMockModuleId(node.source.value)),\n        ),\n      )\n\n      for (const specifier of node.specifiers) {\n        if (\n          t.isImportDefaultSpecifier(specifier) ||\n          t.isImportNamespaceSpecifier(specifier)\n        ) {\n          replacements.push(\n            t.variableDeclaration('const', [\n              t.variableDeclarator(\n                t.identifier(specifier.local.name),\n                t.identifier(mockVar),\n              ),\n            ]),\n          )\n        } else if (t.isImportSpecifier(specifier)) {\n          if (specifier.importKind === 'type') continue\n          const importedName = t.isIdentifier(specifier.imported)\n            ? specifier.imported.name\n            : specifier.imported.value\n          replacements.push(\n            t.variableDeclaration('const', [\n              t.variableDeclarator(\n                t.identifier(specifier.local.name),\n                t.memberExpression(\n                  t.identifier(mockVar),\n                  t.identifier(importedName),\n                ),\n              ),\n            ]),\n          )\n        }\n      }\n\n      ast.program.body.splice(i, 1, ...replacements)\n      modified = true\n      continue\n    }\n\n    if (t.isExportNamedDeclaration(node) && node.source) {\n      if (node.exportKind === 'type') continue\n      if (!deniedSources.has(node.source.value)) continue\n\n      const mockVar = `__tss_deny_${mockCounter++}`\n      const replacements: Array<t.Statement> = []\n\n      replacements.push(\n        t.importDeclaration(\n          [t.importDefaultSpecifier(t.identifier(mockVar))],\n          t.stringLiteral(getMockModuleId(node.source.value)),\n        ),\n      )\n      const exportSpecifiers: Array<{\n        localName: string\n        exportedName: string\n      }> = []\n      for (const specifier of node.specifiers) {\n        if (t.isExportSpecifier(specifier)) {\n          if (specifier.exportKind === 'type') continue\n          const localName = specifier.local.name\n          const exportedName = t.isIdentifier(specifier.exported)\n            ? specifier.exported.name\n            : specifier.exported.value\n\n          const internalVar = `__tss_reexport_${localName}`\n          replacements.push(\n            t.variableDeclaration('const', [\n              t.variableDeclarator(\n                t.identifier(internalVar),\n                t.memberExpression(\n                  t.identifier(mockVar),\n                  t.identifier(localName),\n                ),\n              ),\n            ]),\n          )\n          exportSpecifiers.push({ localName: internalVar, exportedName })\n        }\n      }\n\n      if (exportSpecifiers.length > 0) {\n        replacements.push(\n          t.exportNamedDeclaration(\n            null,\n            exportSpecifiers.map((s) =>\n              t.exportSpecifier(\n                t.identifier(s.localName),\n                t.identifier(s.exportedName),\n              ),\n            ),\n          ),\n        )\n      }\n\n      ast.program.body.splice(i, 1, ...replacements)\n      modified = true\n      continue\n    }\n\n    if (t.isExportAllDeclaration(node)) {\n      if (node.exportKind === 'type') continue\n      if (!deniedSources.has(node.source.value)) continue\n\n      ast.program.body.splice(i, 1)\n      modified = true\n      continue\n    }\n  }\n\n  if (!modified) return undefined\n\n  const result = generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: id,\n    filename: id,\n  })\n\n  return { code: result.code, map: result.map }\n}\n"],"names":[],"mappings":";;;AAMO,SAAS,kBAAkB,MAAuB;AACvD,MAAI,SAAS,aAAa,KAAK,WAAW,EAAG,QAAO;AACpD,QAAM,QAAQ,KAAK,WAAW,CAAC;AAE/B,MACE,EACG,SAAS,MAAM,SAAS,MACxB,SAAS,MAAM,SAAS,OACzB,UAAU,MACV,UAAU;AAGZ,WAAO;AACT,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,UAAM,KAAK,KAAK,WAAW,CAAC;AAE5B,QACE,EACG,MAAM,MAAM,MAAM,MAClB,MAAM,MAAM,MAAM,OAClB,MAAM,MAAM,MAAM,MACnB,OAAO,MACP,OAAO;AAGT,aAAO;AAAA,EACX;AACA,SAAO;AACT;AAMO,SAAS,+BACd,MAC4B;AAC5B,QAAM,MAAM,SAAS,EAAE,MAAM;AAE7B,QAAM,oCAAoB,IAAA;AAC1B,QAAM,MAAM,CAAC,QAAgB,SAAiB;AAC5C,QAAI,SAAS,aAAa,KAAK,WAAW,EAAG;AAC7C,gBAAY,eAAe,QAAQ,MAAM,oBAAI,KAAa,EAAE,IAAI,IAAI;AAAA,EACtE;AAEA,aAAW,QAAQ,IAAI,QAAQ,MAAM;AACnC,QAAI,EAAE,oBAAoB,IAAI,GAAG;AAC/B,UAAI,KAAK,eAAe,OAAQ;AAChC,YAAM,SAAS,KAAK,OAAO;AAC3B,iBAAW,KAAK,KAAK,YAAY;AAC/B,YAAI,CAAC,EAAE,kBAAkB,CAAC,EAAG;AAC7B,YAAI,EAAE,eAAe,OAAQ;AAC7B,cAAM,eAAe,EAAE,aAAa,EAAE,QAAQ,IAC1C,EAAE,SAAS,OACX,EAAE,SAAS;AAEf,YAAI,iBAAiB,UAAW;AAChC,YAAI,QAAQ,YAAY;AAAA,MAC1B;AAAA,IACF;AAEA,QAAI,EAAE,yBAAyB,IAAI,KAAK,KAAK,QAAQ,OAAO;AAC1D,UAAI,KAAK,eAAe,OAAQ;AAChC,YAAM,SAAS,KAAK,OAAO;AAC3B,iBAAW,KAAK,KAAK,YAAY;AAC/B,YAAI,CAAC,EAAE,kBAAkB,CAAC,EAAG;AAC7B,YAAI,EAAE,eAAe,OAAQ;AAC7B,YAAI,QAAQ,EAAE,MAAM,IAAI;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AAEA,QAAM,0BAAU,IAAA;AAChB,aAAW,CAAC,QAAQ,GAAG,KAAK,eAAe;AACzC,QAAI,IAAI,QAAQ,MAAM,KAAK,GAAG,EAAE,MAAM;AAAA,EACxC;AACA,SAAO;AACT;"}